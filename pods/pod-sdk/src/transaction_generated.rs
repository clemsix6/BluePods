// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;

use crate::object_generated::*;

#[allow(unused_imports, dead_code)]
pub mod types {

  use crate::object_generated::*;

pub enum TransactionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Transaction<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Transaction<'a> {
  type Inner = Transaction<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Transaction<'a> {
  pub const VT_HASH: ::flatbuffers::VOffsetT = 4;
  pub const VT_READ_OBJECTS: ::flatbuffers::VOffsetT = 6;
  pub const VT_MUTABLE_OBJECTS: ::flatbuffers::VOffsetT = 8;
  pub const VT_CREATES_OBJECTS: ::flatbuffers::VOffsetT = 10;
  pub const VT_SENDER: ::flatbuffers::VOffsetT = 12;
  pub const VT_SIGNATURE: ::flatbuffers::VOffsetT = 14;
  pub const VT_POD: ::flatbuffers::VOffsetT = 16;
  pub const VT_FUNCTION_NAME: ::flatbuffers::VOffsetT = 18;
  pub const VT_ARGS: ::flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Transaction { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TransactionArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Transaction<'bldr>> {
    let mut builder = TransactionBuilder::new(_fbb);
    if let Some(x) = args.args { builder.add_args(x); }
    if let Some(x) = args.function_name { builder.add_function_name(x); }
    if let Some(x) = args.pod { builder.add_pod(x); }
    if let Some(x) = args.signature { builder.add_signature(x); }
    if let Some(x) = args.sender { builder.add_sender(x); }
    if let Some(x) = args.mutable_objects { builder.add_mutable_objects(x); }
    if let Some(x) = args.read_objects { builder.add_read_objects(x); }
    if let Some(x) = args.hash { builder.add_hash(x); }
    builder.add_creates_objects(args.creates_objects);
    builder.finish()
  }


  #[inline]
  pub fn hash(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(Transaction::VT_HASH, None)}
  }
  #[inline]
  pub fn read_objects(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(Transaction::VT_READ_OBJECTS, None)}
  }
  #[inline]
  pub fn mutable_objects(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(Transaction::VT_MUTABLE_OBJECTS, None)}
  }
  #[inline]
  pub fn creates_objects(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Transaction::VT_CREATES_OBJECTS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn sender(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(Transaction::VT_SENDER, None)}
  }
  #[inline]
  pub fn signature(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(Transaction::VT_SIGNATURE, None)}
  }
  #[inline]
  pub fn pod(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(Transaction::VT_POD, None)}
  }
  #[inline]
  pub fn function_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Transaction::VT_FUNCTION_NAME, None)}
  }
  #[inline]
  pub fn args(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(Transaction::VT_ARGS, None)}
  }
}

impl ::flatbuffers::Verifiable for Transaction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("hash", Self::VT_HASH, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("read_objects", Self::VT_READ_OBJECTS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("mutable_objects", Self::VT_MUTABLE_OBJECTS, false)?
     .visit_field::<bool>("creates_objects", Self::VT_CREATES_OBJECTS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("sender", Self::VT_SENDER, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("signature", Self::VT_SIGNATURE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("pod", Self::VT_POD, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("function_name", Self::VT_FUNCTION_NAME, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("args", Self::VT_ARGS, false)?
     .finish();
    Ok(())
  }
}
pub struct TransactionArgs<'a> {
    pub hash: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
    pub read_objects: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
    pub mutable_objects: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
    pub creates_objects: bool,
    pub sender: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
    pub signature: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
    pub pod: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
    pub function_name: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub args: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for TransactionArgs<'a> {
  #[inline]
  fn default() -> Self {
    TransactionArgs {
      hash: None,
      read_objects: None,
      mutable_objects: None,
      creates_objects: false,
      sender: None,
      signature: None,
      pod: None,
      function_name: None,
      args: None,
    }
  }
}

pub struct TransactionBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> TransactionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_hash(&mut self, hash: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Transaction::VT_HASH, hash);
  }
  #[inline]
  pub fn add_read_objects(&mut self, read_objects: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Transaction::VT_READ_OBJECTS, read_objects);
  }
  #[inline]
  pub fn add_mutable_objects(&mut self, mutable_objects: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Transaction::VT_MUTABLE_OBJECTS, mutable_objects);
  }
  #[inline]
  pub fn add_creates_objects(&mut self, creates_objects: bool) {
    self.fbb_.push_slot::<bool>(Transaction::VT_CREATES_OBJECTS, creates_objects, false);
  }
  #[inline]
  pub fn add_sender(&mut self, sender: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Transaction::VT_SENDER, sender);
  }
  #[inline]
  pub fn add_signature(&mut self, signature: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Transaction::VT_SIGNATURE, signature);
  }
  #[inline]
  pub fn add_pod(&mut self, pod: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Transaction::VT_POD, pod);
  }
  #[inline]
  pub fn add_function_name(&mut self, function_name: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Transaction::VT_FUNCTION_NAME, function_name);
  }
  #[inline]
  pub fn add_args(&mut self, args: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Transaction::VT_ARGS, args);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> TransactionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TransactionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Transaction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Transaction<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Transaction");
      ds.field("hash", &self.hash());
      ds.field("read_objects", &self.read_objects());
      ds.field("mutable_objects", &self.mutable_objects());
      ds.field("creates_objects", &self.creates_objects());
      ds.field("sender", &self.sender());
      ds.field("signature", &self.signature());
      ds.field("pod", &self.pod());
      ds.field("function_name", &self.function_name());
      ds.field("args", &self.args());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Transaction`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_transaction_unchecked`.
pub fn root_as_transaction(buf: &[u8]) -> Result<Transaction<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<Transaction>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Transaction` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_transaction_unchecked`.
pub fn size_prefixed_root_as_transaction(buf: &[u8]) -> Result<Transaction<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<Transaction>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Transaction` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_transaction_unchecked`.
pub fn root_as_transaction_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Transaction<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<Transaction<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Transaction` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_transaction_unchecked`.
pub fn size_prefixed_root_as_transaction_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Transaction<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<Transaction<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Transaction and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Transaction`.
pub unsafe fn root_as_transaction_unchecked(buf: &[u8]) -> Transaction<'_> {
  unsafe { ::flatbuffers::root_unchecked::<Transaction>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Transaction and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Transaction`.
pub unsafe fn size_prefixed_root_as_transaction_unchecked(buf: &[u8]) -> Transaction<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<Transaction>(buf) }
}
#[inline]
pub fn finish_transaction_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<Transaction<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_transaction_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<Transaction<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod types


pub use types::*;
